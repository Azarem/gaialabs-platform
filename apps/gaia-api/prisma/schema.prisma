// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// -------------------
// Master Game Data
// Contains the canonical definition of all assets for a game,
// independent of any specific release.
// -------------------

model Game {
  id           String @id @default(cuid())
  title        String @unique
  description  String?
  platform     String // e.g., "SNES", "Genesis"
  meta         Json?  // For any other metadata

  // Default ROM characteristics (from a "master" or common version)
  romDeveloper Int?
  romMode      Int?
  romChipset   Int?
  romSize      Int?
  ramSize      Int?

  files    GameFile[]
  blocks   GameBlock[]
  releases Release[]
  
  // Game-specific data structures
  mnemonics GameMnemonic[]
  cops      GameCop[]

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // For soft deletes
  createdById String?   // Optional: Link to a User model
  updatedById String?   // Optional: Link to a User model
  deletedById String?

  createdBy User? @relation("CreatedGames", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedGames", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedGames", fields: [deletedById], references: [id])
}

model GameFile {
  id      String @id @default(cuid())
  name    String
  type    String? // e.g., "Graphics", "Text", "Code"
  group   String? // For logical grouping
  scene   String? // e.g., "Intro", "World Map"

  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String

  releaseFiles ReleaseFile[]

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String?
  updatedById String?
  deletedById String?

  createdBy User? @relation("CreatedGameFiles", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedGameFiles", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedGameFiles", fields: [deletedById], references: [id])

  @@unique([gameId, name])
}

model GameBlock {
  id    String  @id @default(cuid())
  name  String
  group String?
  scene String?

  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String

  parts         GamePart[]
  releaseBlocks ReleaseBlock[]

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String?
  updatedById String?
  deletedById String?

  createdBy User? @relation("CreatedGameBlocks", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedGameBlocks", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedGameBlocks", fields: [deletedById], references: [id])

  @@unique([gameId, name])
}

model GamePart {
  id     String  @id @default(cuid())
  name   String
  struct String? // Describes the data structure, e.g., "PlayerStats"
  order  Int     @default(0) // Order within the block

  block       GameBlock @relation(fields: [gameBlockId], references: [id], onDelete: Cascade)
  gameBlockId String

  releaseParts ReleasePart[]

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String?
  updatedById String?
  deletedById String?

  createdBy User? @relation("CreatedGameParts", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedGameParts", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedGameParts", fields: [deletedById], references: [id])

  @@unique([gameBlockId, name])
}


// -------------------
// Release-Specific Data
// Contains overrides and location-specific information for a
// particular game release (e.g., US v1.0, JP v1.1).
// -------------------

model Release {
  id           String @id @default(cuid())
  romVersion   Int // e.g., 0 for "1.0"
  romRegion    Int // e.g., 1 for "US"
  romTitle     String?
  romCode      String?
  romCrc       Int?    // e.g. 0x1C3848C0

  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String

  files  ReleaseFile[]
  blocks ReleaseBlock[]
  parts  ReleasePart[]
  
  // Release-specific data structures
  overrides  ReleaseOverride[]
  rewrites   ReleaseRewrite[]
  transforms ReleaseTransform[]
  labels     ReleaseLabel[]

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String?
  updatedById String?
  deletedById String?

  createdBy User? @relation("CreatedReleases", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedReleases", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedReleases", fields: [deletedById], references: [id])

  @@unique([gameId, romVersion, romRegion])
}

// Override table for GameFile
model ReleaseFile {
  id String @id @default(cuid())

  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  releaseId String

  gameFile   GameFile @relation(fields: [gameFileId], references: [id], onDelete: Cascade)
  gameFileId String

  // --- Overridable fields ---
  name  String?
  type  String?
  group String?
  scene String?

  // --- Release-specific fields ---
  romLocation Int?
  romSize     Int?

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String?
  updatedById String?
  deletedById String?

  createdBy User? @relation("CreatedReleaseFiles", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedReleaseFiles", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedReleaseFiles", fields: [deletedById], references: [id])

  @@unique([releaseId, gameFileId])
}

// Override table for GameBlock
model ReleaseBlock {
  id String @id @default(cuid())
  
  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  releaseId String

  gameBlock   GameBlock @relation(fields: [gameBlockId], references: [id], onDelete: Cascade)
  gameBlockId String

  // --- Overridable fields ---
  name  String?
  group String?
  scene String?
  
  // A ReleaseBlock is an organizational unit and does not have a direct location.
  // Its Parts define the content and locations.

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String?
  updatedById String?
  deletedById String?

  createdBy User? @relation("CreatedReleaseBlocks", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedReleaseBlocks", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedReleaseBlocks", fields: [deletedById], references: [id])

  @@unique([releaseId, gameBlockId])
}

// Override table for GamePart
model ReleasePart {
  id String @id @default(cuid())

  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  releaseId String

  gamePart   GamePart @relation(fields: [gamePartId], references: [id], onDelete: Cascade)
  gamePartId String

  // --- Overridable fields ---
  name   String?
  struct String?
  order  Int?

  // --- Release-specific fields ---
  romLocation Int? // The address of the part in the ROM
  romSize     Int?

  // Audit fields
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String?
  updatedById String?
  deletedById String?

  createdBy User? @relation("CreatedReleaseParts", fields: [createdById], references: [id])
  updatedBy User? @relation("UpdatedReleaseParts", fields: [updatedById], references: [id])
  deletedBy User? @relation("DeletedReleaseParts", fields: [deletedById], references: [id])

  @@unique([releaseId, gamePartId])
}

// -------------------
// Authentication & User Models
// Based on the standard NextAuth.js Prisma Adapter schema for flexibility.
// -------------------

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  role          UserRole  @default(USER)

  accounts Account[]
  sessions Session[]

  // Audit fields
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // --- Relations for tracking user actions ---
  createdGames        Game[]         @relation("CreatedGames")
  updatedGames        Game[]         @relation("UpdatedGames")
  deletedGames        Game[]         @relation("DeletedGames")

  createdGameFiles    GameFile[]     @relation("CreatedGameFiles")
  updatedGameFiles    GameFile[]     @relation("UpdatedGameFiles")
  deletedGameFiles    GameFile[]     @relation("DeletedGameFiles")

  createdGameBlocks   GameBlock[]    @relation("CreatedGameBlocks")
  updatedGameBlocks   GameBlock[]    @relation("UpdatedGameBlocks")
  deletedGameBlocks   GameBlock[]    @relation("DeletedGameBlocks")

  createdGameParts    GamePart[]     @relation("CreatedGameParts")
  updatedGameParts    GamePart[]     @relation("UpdatedGameParts")
  deletedGameParts    GamePart[]     @relation("DeletedGameParts")

  createdReleases     Release[]      @relation("CreatedReleases")
  updatedReleases     Release[]      @relation("UpdatedReleases")
  deletedReleases     Release[]      @relation("DeletedReleases")

  createdReleaseFiles ReleaseFile[]  @relation("CreatedReleaseFiles")
  updatedReleaseFiles ReleaseFile[]  @relation("UpdatedReleaseFiles")
  deletedReleaseFiles ReleaseFile[]  @relation("DeletedReleaseFiles")

  createdReleaseBlocks ReleaseBlock[] @relation("CreatedReleaseBlocks")
  updatedReleaseBlocks ReleaseBlock[] @relation("UpdatedReleaseBlocks")
  deletedReleaseBlocks ReleaseBlock[] @relation("DeletedReleaseBlocks")

  createdReleaseParts ReleasePart[]  @relation("CreatedReleaseParts")
  updatedReleaseParts ReleasePart[]  @relation("UpdatedReleaseParts")
  deletedReleaseParts ReleasePart[]  @relation("DeletedReleaseParts")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

// =====================================================
// 65C816 PROCESSOR INSTRUCTION SET MODELS
// =====================================================

enum ProcessorFlag {
  N  // Negative
  V  // Overflow
  M  // Memory/Accumulator width
  X  // Index register width
  D  // Decimal mode
  I  // Interrupt disable
  Z  // Zero
  C  // Carry
  B  // Break
  E  // Emulation mode
  WILDCARD @map("*") // Special wildcard flag
}

enum AddressingModeType {
  Immediate
  Absolute
  AbsoluteLong
  DirectPage
  DirectPageIndirect
  DirectPageIndirectLong
  AbsoluteIndexedX
  AbsoluteLongIndexedX
  AbsoluteIndexedY
  DirectPageIndexedX
  DirectPageIndexedY
  DirectPageIndexedIndirectX
  DirectPageIndirectIndexedY
  DirectPageIndirectLongIndexedY
  StackRelative
  StackRelativeIndirectIndexedY
  Accumulator
  Implied
  Stack
  StackInterrupt
  PCRelative
  PCRelativeLong
  AbsoluteIndirect
  AbsoluteIndirectLong
  AbsoluteIndexedIndirect
  BlockMove
}

enum InstructionCategory {
  LoadStore
  Arithmetic
  Logical
  Shift
  ControlFlow
  Branch
  System
  Interrupt
  Flags
  Stack
  Transfer
  BlockMove
  Special
}

enum OperandType {
  Absolute
  AbsoluteLong
  Direct
  Immediate
  None
  Label
  Byte
  BankPair
  InterruptVector
}

model InstructionSet {
  id               String   @id @default(cuid())
  name             String   @unique
  version          String
  description      String?
  baseProcessor    String?
  generatedFrom    String?
  totalInstructions Int
  totalVariants    Int
  
  // JSON fields for complex metadata
  cycleNotation    Json     // Cycle timing notation and examples
  metadata         Json?    // Additional metadata
  
  // Relationships
  instructionGroups InstructionGroup[]
  validationRules   ValidationRule[]
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model InstructionGroup {
  id             String              @id @default(cuid())
  name           String              
  category       InstructionCategory
  description    String?
  
  // Relationships
  instructionSet InstructionSet      @relation(fields: [instructionSetId], references: [id], onDelete: Cascade)
  instructionSetId String
  instructions   Instruction[]
  
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  
  @@unique([instructionSetId, name])
}

model Instruction {
  id              String              @id @default(cuid())
  mnemonic        String              // e.g., "LDA", "STA"
  description     String
  affectedFlags   ProcessorFlag[]     // Flags affected by this instruction
  
  // Relationships
  instructionGroup InstructionGroup   @relation(fields: [instructionGroupId], references: [id], onDelete: Cascade)
  instructionGroupId String
  variants        InstructionVariant[]
  
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  @@unique([instructionGroupId, mnemonic])
}

model InstructionVariant {
  id               String            @id @default(cuid())
  opcode           Int               @unique // 0-255 opcode value
  size             Int?              // Size in bytes, null for flag-dependent
  isFlagDependent  Boolean           @default(false) // True if size depends on processor flags
  
  // Cycle timing stored as JSON for complex conditional logic
  cycleTiming      Json              // CycleTiming object with base, penalties, description, etc.
  
  // Relationships
  instruction      Instruction       @relation(fields: [instructionId], references: [id], onDelete: Cascade)
  instructionId    String
  addressingMode   AddressingMode    @relation(fields: [addressingModeId], references: [id])
  addressingModeId String
  
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
}

model AddressingMode {
  id                  String               @id @default(cuid())
  mode                AddressingModeType   @unique
  shorthand           String               @unique // e.g., "abs", "imm"
  operandType         OperandType
  description         String
  officialName        String?
  length              Int                  // Instruction length in bytes
  format              String               // Format pattern like "$OP $LL $HH"
  formatString        String               // Format string like "${0:X4}"
  parseRegex          String               // Regex for parsing assembly
  operandSize         Int                  // Size of operand in bytes
  supportsSymbols     Boolean              @default(false)
  bankWrapping        Boolean              @default(false)
  pageWrapping        Boolean              @default(false)
  
  // JSON fields for complex validation and configuration
  validationPatterns  Json                 // Validation regex patterns
  examples            Json                 // Example usage patterns
  
  // Relationships  
  instructionVariants InstructionVariant[]
  
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
}

model ValidationRule {
  id                String         @id @default(cuid())
  name              String
  category          String         // e.g., "operandSizeValidation", "instructionValidation"
  
  // JSON field to store complex validation logic
  rules             Json           // Complete validation rule object
  
  // Relationships
  instructionSet    InstructionSet @relation(fields: [instructionSetId], references: [id], onDelete: Cascade)
  instructionSetId  String
  
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  
  @@unique([instructionSetId, name, category])
}

// =====================================================
// GAME-SPECIFIC DATA MODELS
// =====================================================

model GameMnemonic {
  id    String @id @default(cuid())
  key   Int    // Memory address key
  value String // Mnemonic name/value
  
  // Relationships
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([gameId, key])
}

model GameCop {
  id    String  @id @default(cuid())
  code  Int     // COP operation code
  mnem  String  // Mnemonic representation  
  size  Int     // Size in bytes
  halt  Boolean // Whether this operation halts execution
  parts Json    // Array of parts/parameters
  
  // Relationships
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([gameId, code])
}

// =====================================================
// RELEASE-SPECIFIC DATA MODELS
// =====================================================

model ReleaseOverride {
  id       String @id @default(cuid())
  data     Json   // Override data structure (flexible for different override types)
  
  // Relationships
  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  releaseId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ReleaseRewrite {
  id       String @id @default(cuid())
  data     Json   // Rewrite data structure (flexible for different rewrite types)
  
  // Relationships
  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  releaseId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ReleaseTransform {
  id         String @id @default(cuid())
  block      String // Block name that this transform applies to
  transforms Json   // Array of key-value transform rules
  
  // Relationships
  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  releaseId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([releaseId, block])
}

model ReleaseLabel {
  id       String @id @default(cuid())
  location Int    // Memory location/address
  label    String // Label name
  
  // Relationships
  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  releaseId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([releaseId, location])
}
